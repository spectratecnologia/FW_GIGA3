#include "can.h"
#include "multitask/multitask.h"
#include "LCD/lcd_screen.h"

void initCAN1();
void initCAN2();

#define NUM_EMERGENCY_PORT_TO_CHECKSUM_MPX2808 28

static uint32_t receivedPackets=0;
static uint32_t transmitErrors=0;

bool startedEmergencyFlag[NUM_MPX] = {0};

void initCANs(){
	printf("[CANs]Starting Setup\n");

	int i;
	for (i=0; i<NUM_MPX; i++) {
		resetEmergencyCtrl(i);
		multiplex.mpx[i].ackIndex = 0;
	}

	initCAN1();

	initCAN2();

	printf("[CANs]Setup complete\n");
}

void initCAN1(){
	GPIO_InitTypeDef  		GPIO_InitStructure;
	CAN_InitTypeDef        	CAN_InitStructure;
	CAN_FilterInitTypeDef  	CAN_FilterInitStructure;
	NVIC_InitTypeDef  		NVIC_InitStructure;

	/* Enable CAN1 clocks  */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);

	/* Configure CAN1 pin: RX */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* Configure CAN1 pin: TX */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_PinRemapConfig(GPIO_Remap1_CAN1,ENABLE);


	/* CAN register init */
	CAN_DeInit(CAN1);
	CAN_StructInit(&CAN_InitStructure);

	/* CAN cell init */
	CAN_InitStructure.CAN_TTCM = DISABLE;
	CAN_InitStructure.CAN_ABOM = DISABLE;
	CAN_InitStructure.CAN_AWUM = DISABLE;
	CAN_InitStructure.CAN_NART = DISABLE;
	CAN_InitStructure.CAN_RFLM = DISABLE;
	CAN_InitStructure.CAN_TXFP = DISABLE;
	CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;

	/* CAN Baudrate = 250KBps*/
	///baudrate=1/(1tq + BS1tq + BS2tq) // Prescaler*2 = tq/ (1/72Mhz). (9=>250K, 18=> 150K). Leandro
	CAN_InitStructure.CAN_SJW = CAN_SJW_2tq;
	CAN_InitStructure.CAN_BS1 = CAN_BS1_11tq;
	CAN_InitStructure.CAN_BS2 = CAN_BS2_4tq;
	CAN_InitStructure.CAN_Prescaler = 9;
	CAN_Init(CAN1, &CAN_InitStructure);

	/* CAN filter init */
	CAN_FilterInitStructure.CAN_FilterNumber = 0;
	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
	CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
	CAN_FilterInit(&CAN_FilterInitStructure);


	/* CAN reception interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = CAN1_RX0_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* CAN Status change error */
	NVIC_InitStructure.NVIC_IRQChannel = CAN1_SCE_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);


	/* Enable TRANSCEIVERS */
	/* 	Init PB10 - Transceiver RS*/
	GPIO_InitStructure.GPIO_Pin	= GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_Out_OD;
	GPIO_InitStructure.GPIO_Speed	= GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_WriteBit(GPIOB,GPIO_Pin_10, Bit_RESET);

	/* IT Configuration for CAN1 fifo*/
	CAN_ITConfig(CAN1, CAN_IT_FMP0 | CAN_IT_BOF | CAN_IT_ERR, ENABLE);

}

void initCAN2(){
	GPIO_InitTypeDef  GPIO_InitStructure;
	CAN_InitTypeDef        CAN_InitStructure;
	CAN_FilterInitTypeDef  CAN_FilterInitStructure;
	NVIC_InitTypeDef  NVIC_InitStructure;

	/* Enable CAN2 clocks  */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE);

	/* Configure CAN2 pin: RX */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* Configure CAN2 pin: TX */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_PinRemapConfig(GPIO_Remap_CAN2,ENABLE);


	/* CAN register init */
	CAN_DeInit(CAN2);
	CAN_StructInit(&CAN_InitStructure);

	/* CAN cell init */
	CAN_InitStructure.CAN_TTCM = DISABLE;
	CAN_InitStructure.CAN_ABOM = DISABLE;
	CAN_InitStructure.CAN_AWUM = DISABLE;
	CAN_InitStructure.CAN_NART = DISABLE;
	CAN_InitStructure.CAN_RFLM = DISABLE;
	CAN_InitStructure.CAN_TXFP = DISABLE;
	CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;

	/* CAN Baudrate = 250KBps*/
	///baudrate=1/(1tq + BS1tq + BS2tq) // Prescaler*2 = tq/ (1/72Mhz). (9=>250K, 18=> 150K). Leandro
	CAN_InitStructure.CAN_SJW = CAN_SJW_2tq;
	CAN_InitStructure.CAN_BS1 = CAN_BS1_11tq;
	CAN_InitStructure.CAN_BS2 = CAN_BS2_4tq;
	CAN_InitStructure.CAN_Prescaler = 9;
	CAN_Init(CAN2, &CAN_InitStructure);

	/* CAN filter init */
	CAN_FilterInitStructure.CAN_FilterNumber = 14;
	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
	CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
	CAN_FilterInit(&CAN_FilterInitStructure);


	/* Define interrupt priority */
	NVIC_InitStructure.NVIC_IRQChannel = CAN2_RX0_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* IT Configuration for CAN1 */
	CAN_ITConfig(CAN2, CAN_IT_FMP0, ENABLE);
}


static inline int8_t getMpxIndex(uint8_t canAddress){
	int i;
	for(i=0;i<multiplex.numberOfConfiguredMpx;i++){
		if ( multiplex.mpx[i].mpxId == canAddress){
			return i;
		}
	}
	return -1;
}

inline void onCAN1ReceiveInterrupt(){
	static CanRxMsg rxMessage;
	static MsgId msgId;
	static int i;

	CAN_Receive(CAN1, CAN_FIFO0, &rxMessage);

	msgId.extId = rxMessage.ExtId;

	int8_t mpxIndex = getMpxIndex(msgId.SA);

	if(mpxIndex!=-1){
		multiplex.mpx[mpxIndex].lastTimeSeen = sysTickTimer;
	}

	if (msgId.command == CAN_COMMAND_WRITE_ACK){
		for(i=0;i<multiplex.numberOfConfiguredMpx;i++){
			if( (!multiplex.mpx[i].ackReceived) && (multiplex.mpx[i].ackIndex == msgId.index)){
				//uint32_t tick = sysTickTimer;
				//printf("[%d]ackIndex:%d, ackReceived:%d\n",tick,multiplex.mpx[i].ackIndex,multiplex.mpx[i].ackReceived);
				multiplex.mpx[i].ackReceived = true;
			}
		}

		/* Process received  ACK from outputPorts*/
		if ( (mpxIndex!=-1) && (msgId.index < NUM_PORTS)){
			multiplex.mpx[mpxIndex].outputChanged[msgId.index] = false;
		}
	}

	if (msgId.command == CAN_COMMAND_BROADCAST){
		uint8_t broadcastType = (msgId.index & 0xf0);
		if (broadcastType == CAN_BROADCAST_KEY_STATE_MASK){
			uint8_t keyOffset = (msgId.index & 0x0f) * 8;
			if ( keyOffset<=(NUM_PTC_KEY-8)){
				int i=0;
				for(i=0;i<8;i++){
					/* Skip command keys */
					if ( (1<=(i+keyOffset)) && ((i+keyOffset)<=4) ){
						continue;
					}
					if (multiplex.currentPtc.keyState[i+keyOffset] != rxMessage.Data[i]){
						nextVirtualKeyState(i+keyOffset,false);
					}
				}
			}
		}
		else if (broadcastType == CAN_BROADCAST_DIGITAL_INPUT_MASK) {
			/* If received broadcast is from a configured MPX */
			if (mpxIndex!=-1){
				uint8_t portOffset = (msgId.index & 0x0f) * 8;
				if ( portOffset<=(NUM_PORTS-8)){
					memcpy( &multiplex.mpx[mpxIndex].portInput[portOffset],rxMessage.Data,8);
				}
				else{
					/* Can freeze firmware due CAN priority been the highest */
					//printf("[CAN]Digital input port out of range, portOffset=%d\n",portOffset);
				}
			}
		}
		else if (broadcastType == CAN_BROADCAST_ANALOG_INPUT_MASK) {
			/* If received broadcast is from a configured MPX */
			if (mpxIndex!=-1){
				/* 4 analog values per port */
				uint8_t analogValueOffset = (msgId.index & 0x0f) * 4;

				uint16_t memoryOffset = getMpxAnalogMemoryAddress(mpxIndex,analogValueOffset);

				/* Skip if out of range
				 * TODO: check this out of range comparison */
				if ( (memoryOffset-4) >MEMORY_INDEX_MPX_END){
					return;
				}

				union{
					int8_t analogInput[8];
					int16_t analogValue[4];
				} analogParser;

				memcpy( &analogParser,rxMessage.Data,8);

				int i;
				for(i=0;i<4;i++){
					multiplex.currentPtc.memory[memoryOffset+i] = (int16_t)((int8_t)analogParser.analogValue[i]);
				}
			}
		}
		else if (broadcastType == CAN_BROADCAST_FLAGS_MASK) {

		}

		else if (msgId.index == CAN_BROADCAST_MPX_INFO) {

		}
		else if(msgId.index == CAN_BROADCAST_MPX_FLASH_INFO) {
			//printf("[CAN]FLASH INFO MSG\n");
			/* If different from 0 PTC is running configureMPX routine to this mpxIndex */
			if (multiplex.mpx[mpxIndex].ackIndex == CAN_INDEX_EME_IGN_START) {
				uint32_t myCheckSum = portEmergencyCheckSum(mpxIndex);
				uint16_t checkSumFlash, chackSumFlashCalc;
				memcpy(&checkSumFlash, &rxMessage.Data[4], 2);
				memcpy(&chackSumFlashCalc, &rxMessage.Data[6], 2);
				//printf("[CAN]MPX %d my CheckSum Calculated: 0x%X\n", mpxIndex, myCheckSum);
				//printf("[CAN]MPX %d CheckSum Flash: 0x%X\n", mpxIndex, checkSumFlash);
				//printf("[CAN]MPX %d CheckSum Calc Flash: 0x%X\n", mpxIndex, chackSumFlashCalc);
				/* Verifies if there is any inconsistency in the check sums */
				if(checkSumFlash != chackSumFlashCalc || checkSumFlash != myCheckSum || chackSumFlashCalc != myCheckSum) {
				/* Avoid overflow and counter backing to zero */
				if(mpxEmergencyControl[mpxIndex].flashErrorCounter <= EME_CTRL_MAX_FLASH_ERROR
							&& !mpxEmergencyControl[mpxIndex].emergencyProcedureTriggered) {
						mpxEmergencyControl[mpxIndex].flashErrorCounter++;
						mpxEmergencyControl[mpxIndex].emergencyProcedureTriggered = true;
						startedEmergencyFlag[mpxIndex] = true;
						//printf("[CAN]Trying Emergency routine\n");
					}
					else {
						if(mpxEmergencyControl[mpxIndex].flashErrorCounter > EME_CTRL_MAX_FLASH_ERROR) {
							mpxEmergencyControl[mpxIndex].emergencyProcedureTriggered = false;
							//printf("[CAN]Flash Error max reached\n");
						}
					}
				}
				else {
					//printf("[CAN]Check sum OK\n");
					mpxEmergencyControl[mpxIndex].flashErrorCounter = 0;
					mpxEmergencyControl[mpxIndex].emergencyProcedureTriggered = false;
				}
			}
			else {
				//printf("[CAN]I'm Processing Emergency Routine Mpx %d\n", mpxIndex);
			}
		}
		else{
			/* Can freeze firmware due CAN priority been the highest */
			//printf("[CAN]Unknown broadcast type:0x%X\n",broadcastType);
		}
	}

	receivedPackets++;
}

inline void onCAN1StatusChangeError(){
    if(CAN_GetFlagStatus(CAN1,CAN_FLAG_BOF) == SET){
		displayErrorMessage("Falha de","comunicacao(bof)",5000, PRIORITY_3);
		initCAN1();
		CAN_ClearITPendingBit(CAN1,CAN_IT_BOF);
    }
}

uint32_t transmitErrorsCount(){
	return transmitErrors;
}

uint32_t receivedCanPacketsCount(){
	return receivedPackets;
}

void sendBroadcast2(){
	CanTxMsg txMessage;
	/* Transmit */
	MsgId msgId;
	msgId.command = CAN_COMMAND_WRITE;
	msgId.index = 1;
	msgId.SA = MY_ID;
	msgId.DA = 0x80;
	txMessage.ExtId = msgId.extId;

	txMessage.RTR = CAN_RTR_DATA;
	txMessage.IDE = CAN_ID_EXT;
	txMessage.DLC = 8;
	txMessage.Data[0] = 0;
	txMessage.Data[1] = 0;
	txMessage.Data[2] = 0;
	txMessage.Data[3] = 0;
	txMessage.Data[4] = 0;
	txMessage.Data[5] = 0;
	txMessage.Data[6] = 0;
	txMessage.Data[7] = 0;
	static int a=0;

	//mempcpy(txMessage.Data,&a,4);
	a++;
	CAN_Transmit(CAN1, &txMessage);

	msgId.command = CAN_COMMAND_READ;
	msgId.index = 1;
	msgId.SA = MY_ID;
	msgId.DA = 0x80;
	txMessage.ExtId = msgId.extId;
	CAN_Transmit(CAN1, &txMessage);
}


void sendCanPacket(uint8_t command,uint8_t index, uint8_t source, uint8_t dest, uint8_t *data, uint8_t numBytes ){
	const uint32_t CAN_TRANSMIT_TIMEOUT=3;
	CanTxMsg txMessage;

	/* Build  ExtId */
	MsgId msgId;
	msgId.command = command;
	msgId.index = index;
	msgId.SA = source;
	msgId.DA = dest;
	txMessage.ExtId = msgId.extId;

	/* Copy data */
	memcpy(txMessage.Data,data,numBytes);

	/* Set parameters */
	txMessage.RTR = CAN_RTR_DATA;
	txMessage.IDE = CAN_ID_EXT;
	txMessage.DLC = numBytes;

	/* Send Packet */
	uint8_t transmitMailbox= CAN_Transmit(CAN1, &txMessage);

	uint32_t startTime=sysTickTimer;
	/* Wait to transmit packet */
	while(CAN_TransmitStatus(CAN1,transmitMailbox) == CAN_TxStatus_Pending){
		if (achievedTimeout(startTime,CAN_TRANSMIT_TIMEOUT)){
			/* Display message with error */
			printExtId(txMessage.ExtId);
			transmitErrors++;
			break;
		}
	}
}

void CAN_writePort(uint8_t mpxId, uint8_t port, PortParameter *portParameter){
	sendCanPacket(CAN_COMMAND_WRITE,port,MY_ID,mpxId,(uint8_t*)portParameter,8);
}

void printExtId(uint32_t extId){
	MsgId msgId;
	msgId.extId = extId;
	printf("[CANs]printExtId command:0x%X, index:0x%X, SA:0x%X, DA:0x%X\n",msgId.command,msgId.index,msgId.SA,msgId.DA);
}

void turnOffAllMPXsPorts(){
	int mpxIndex,portIndex;
	static PortParameter portOff;
	portOff.mode = 0;
	portOff.duty = 0;
	portOff.fastSoftUp = 0;
	portOff.fastSoftDown = 0;
	portOff.ton = 0;
	portOff.toff = 0;
	portOff.slowSoftUp = 0;
	portOff.slowSoftDown = 0;
	for (mpxIndex = 0; mpxIndex < multiplex.numberOfConfiguredMpx; mpxIndex++) {
		for (portIndex = 0; portIndex < multiplex.mpx[mpxIndex].numPorts; portIndex++) {
			multiplex.mpx[mpxIndex].outputChanged[portIndex] = true;
			multiplex.mpx[mpxIndex].portOutput[portIndex] = portOff;
		}
	}
}


uint32_t portEmergencyCheckSum (uint8_t mpxIndex) {
	if(mpxIndex >= NUM_MPX)
		return 0xFFFF;

	int i=0, j=0, sizeStruct = sizeof(PortParameter);
	uint32_t checkSum=0;
	uint8_t *emeIgn, *emeNIgn;

	emeIgn = (uint8_t*)&multiplex.mpx[mpxIndex].portEmeIgn[0];
	emeNIgn = (uint8_t*)&multiplex.mpx[mpxIndex].portEmeNIgn[0];

	for (i=0; i<NUM_EMERGENCY_PORT_TO_CHECKSUM_MPX2808; i++) {
		for(j=0; j<sizeStruct; j++) {
			checkSum += (uint8_t)(*emeIgn);
			checkSum += (uint8_t)(*emeNIgn);
			/* +1 Because the struct is byte aligned */
			emeIgn+=1;
			emeNIgn+=1;
		}
	}

	return checkSum;
}

void inline resetEmergencyCtrl(uint8_t mxpIndex) {
	mpxEmergencyControl[mxpIndex].timeElapsed = 0;
	mpxEmergencyControl[mxpIndex].flashErrorCounter = 0;
	mpxEmergencyControl[mxpIndex].emergencyProcedureTriggered = false;
}

/*
 * This Function must be called at the moment that the
 * emergency procedure starts writing the first emergency
 * port. Index number 64.
 */
bool startedEmergencyFunc (uint8_t mpxIndex) {
	bool temp = startedEmergencyFlag[mpxIndex]; /* This flag is true while this function is not called */
	startedEmergencyFlag[mpxIndex] = false;
	return temp;
}


